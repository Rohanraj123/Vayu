**Why:**

Go is the language of choice for cloud-native, microservices, and infrastructure tools. Building an **API Gateway** will expose you to HTTP internals, middleware, reverse proxies, load balancing, and distributed systems.

**Features you can implement:**

1. **Core Reverse Proxy**
    - Accept requests and forward them to backend services.
    - Support HTTP/2 and WebSockets.
2. **Routing & Load Balancing**
    - Path-based routing (`/api/v1/*` → service A, `/api/v2/*` → service B).
    - Load balancing strategies (round-robin, least connections, IP-hash).
3. **Middleware System**
    - Authentication (JWT, API keys, OAuth2).
    - Rate limiting & request throttling.
    - Logging & request tracing.
4. **Admin API & Config Management**
    - Dynamic config reload (YAML/JSON or etcd/Consul).
    - Hot reload without downtime.
5. **Observability & Security**
    - Metrics (Prometheus, OpenTelemetry).
    - Circuit breaker / Retry logic.
    - TLS termination.
6. **Scalability**
    - Horizontal scaling with Kubernetes Ingress.
    - Benchmarking with `wrk` or `hey` to prove performance.

**What you’ll learn/cover:**

- Concurrency with goroutines & channels.
- Low-level networking with Go’s `net/http`.
- API design and request lifecycle.
- Cloud-native integrations (etcd/Consul, Prometheus).
- Kubernetes concepts (Ingress, Services).
- Writing high-performance, memory-safe code.

At the end, you’ll basically have a **mini API Gateway/Ingress Controller**, which is a huge plus for a Golang role.
